<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>User Guide</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">funcool/rumext</span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="user-guide.html"><div class="inner"><span>User Guide</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="rumext.v2.html"><div class="inner"><span>rumext.v2</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#user-guide" id="user-guide"></a>User Guide</h1>
<p>Simple and Decomplected UI library based on React &gt;= 18 focused on performance.</p>
<p>Add to deps.edn:</p>
<pre><code class="language-clojure">funcool/rumext
{:git/tag "v2.11"
 :git/sha "4140a50"
 :git/url "https://github.com/funcool/rumext.git"}
</code></pre>
<h2><a href="#first-steps" id="first-steps"></a>First Steps</h2>
<p>Function components as it’s name says, are defined using plain functions. Rumext exposes a lighweigh macro over a <code>fn</code> that convert props from js-object to cljs map (shallow) and exposes a facility for docorate (wrap) with other higher-order components.</p>
<p>Let’s see a example of how to define a component:</p>
<pre><code class="language-clojure">(require '[rumext.v2 :as mf])

(mf/defc title
  [{:keys [name] :as props}]
  [:div {:class "label"} name])
</code></pre>
<p>For performance reasons, you most likely want the props to arrive as is, as a javascript object. For this case, you should use the metadata <code>::mf/props :obj</code> for completly avoid props wrapping overhead (see the next section, where it goes into more depth on the topic).</p>
<pre><code class="language-clojure">(mf/defc title
  {::mf/props :obj}
  [props]
  (let [name (unchecked-get props "name")]
    [:div {:class "label"} name]))
</code></pre>
<p>And finally, we mount the component on the dom:</p>
<pre><code class="language-clojure">(ns myname.space
  (:require
   [goog.dom :as dom]
   [rumext.v2 :as mf]))

(def root (mf/create-root (dom/getElement "app")))
(mf/render! root (mf/element title #js {:title "hello wolrd"}))
</code></pre>
<h2><a href="#props-destructuring" id="props-destructuring"></a>Props &amp; Destructuring</h2>
<p>There are two way to approach props and its destructuring. By default (if not explicitly set by metadata) the props objects has the clojure hash-map type, and follows the already known clojure approach for destructuring.</p>
<pre><code class="language-clojure">(mf/defc title
  [{:keys [name] :as props}]
  (assert (map? props) "expected map")
  (assert (string? name) "expected string")

  [:div {:class "label"} name])
</code></pre>
<p>Not passing any value for <code>::mf/props</code> is equivalent to passing <code>::mf/props :clj</code>. So this code is equivalent:</p>
<pre><code class="language-clojure">(mf/defc title
  {::mf/props :clj}
  [{:keys [name] :as props}]
  (assert (map? props) "expected map")
  (assert (string? name) "expected string")

  [:div {:class "label"} name])
</code></pre>
<p>That approach is very convenient because when you start prototyping, the received props obeys the already known idioms, and all works in a way like the component is a simple clojure function.</p>
<p>But, this approach has inconvenience of the need to transform from js object to clojure hash-map on each render and this has performance penalization. In the majority of cases this has no isues at all.</p>
<p>But in cases when performance is important, it is recommended to use the <code>::mf/props :obj</code> which completly removes the transformation overhead.</p>
<p>The component functions with <code>::mf/props :obj</code> also has support for the already familiar destructuring idiom. Internally, this compiles to code that directly accesses properties within the props object. The only thing to keep in mind, whether you use destructuring or not, <strong>is that the props object is a flat js object and not a clojure hash-map</strong>.</p>
<pre><code class="language-clojure">(mf/defc title
  {::mf/props :obj}
  [{:keys [name] :as props}]
  (assert (object? props) "expected object")
  (assert (string? name) "expected string")
  (assert (unchecked-get props "name") "expected string")

  [:label {:class "label"} name])
</code></pre>
<p>An additional idiom, only available in case of using destructuring with props as a js object: is the possibility of obtaining an object with all properties not destructured:</p>
<pre><code class="language-clojure">(mf/defc title
  {::mf/props :obj}
  [{:keys [name] :as props :rest other}]
  (assert (object? props) "expected object")
  (assert (object? other) "expected map")
  (assert (nil? (unchecked-get other "name")) "no name in other")

  ;; The `:&gt;` will be explained later
  [:&gt; :label other name])
</code></pre>
<p>This allows you to extract the props that the component has control of and leave the rest in an object that can be passed as is to the next element.</p>
<h2><a href="#jsx-hiccup" id="jsx-hiccup"></a>JSX / Hiccup</h2>
<p>You may be already familiar with hiccup syntax (which is equivalent to the react JSX) for defining the react dom. The intention on this section is explain only the essential part of it and the peculiarities of rumext.</p>
<h3><a href="#introduction" id="introduction"></a>Introduction</h3>
<p>Lets start with simple generic elements like <code>div</code>:</p>
<pre><code class="language-clojure">[:div {:class "foobar"
       :style {:background-color "red"}
       :on-click some-on-click-fn}
  "Hello World"]
</code></pre>
<p>The props and the style are transformed at compile time to a js object transforming all keys from lisp-case to camelCase (and rename <code>:class</code> to <code>className</code>); so the compilation result to something like this:</p>
<pre><code class="language-js">const h = React.createElement;

h("div", {className: "foobar",
          style: {"backgroundColor": "red"},
          onClick=someFn},
          "Hello World");
</code></pre>
<p>It should be noted that this transformation is only done to properties that are keyword type and that properties that begin with <code>data-</code> and <code>aria-</code> are left as is without transforming just like the string keys. The properties can be passed directly using camelCase syntax (as react nativelly expects) if you want.</p>
<h3><a href="#handlers-call-conventions" id="handlers-call-conventions"></a>Handlers &amp; Call Conventions</h3>
<p>There are times when we’ll need:</p>
<ul>
<li>the element name to be chosen dynamically or constructed in runtime;</li>
<li>the props to be build dinamically</li>
<li>create an element from user defined component</li>
</ul>
<p>For this purpose, rumext exposes a special handlers, each one exposing its own call convention: <code>:&amp;</code> and <code>:&gt;</code>.</p>
<p>Lets start with <code>:&amp;</code> handler. We will use it when we have 100% control of the props and we do not want any type of transformation to be done to them (usually when we are talking about large components, you probably do not reuse that they represent a page or a section of that page, but not limited to). All props passed to the element will be passed as-is, without any kind of transformations to the prop keys nor values.</p>
<pre><code class="language-clojure">(mf/defc title
  {::mf/props :obj}
  [{:keys [name on-click]}]
  [:div {:class "label" :on-click on-click} name])

(mf/defc my-big-component
  []
  [:&amp; title {:name "foobar" :on-click some-fn}])
</code></pre>
<p>And for completeness, an example without destructuring:</p>
<pre><code class="language-clojure">(mf/defc title
  {::mf/props :obj}
  [props]
  (let [name     (unchecked-get props "name")
        on-click (unchecked-get props "on-click")]
    [:div {:class "label" :on-click on-click} name]))

(mf/defc my-big-component
  []
  [:&amp; title {:name "foobar" :on-click some-fn}])
</code></pre>
<p>This is probably the handler that you will use the most time.</p>
<p>Then, we also have the <code>:&gt;</code> handler. We will use it when we have the following situations:</p>
<ul>
<li>We want to decide the element name dynamicaly</li>
</ul>
<pre><code class="language-clojure">(let [element (if something "div" "span")]
  [:&gt; element {:class "foobar"
               :style {:background-color "red"}
               :on-click some-on-click-fn}
    "Hello World"])
</code></pre>
<ul>
<li>We want to build and pass props dinamically to create a DOM native element (note that the props are always js plain objects and using react naming convention)</li>
</ul>
<pre><code class="language-clojure">(let [props #js {:className "fooBar"
                 :style #js {:backgroundColor "red"}
                 :onClick some-on-click}]
  [:&gt; "div" props "Hello World"])
</code></pre>
<ul>
<li>we are creating a reusable component that is probably wrapping one or more native elements of the virtual dom and we simply want to extend its behavior controlling only a subset of props, where the rest of the props that are not controlled would be passed as is to the next native element.</li>
</ul>
<pre><code class="language-clojure">(mf/defc my-label
  {::mf/props :obj}
  [{:keys [name className] :rest props}]
  (let [class (or className "my-label")
        props (mf/spread props {:className class})]
    [:&gt; :label props name]))

(mf/defc other-component
  []
  [:&gt; my-label {:name "foobar" :on-click some-fn}])
</code></pre>
<p>So, all the the props passed to the <code>:&gt;</code> handler on creating an element from <code>my-label</code> component are transformed at compile-time to an js object following react convention (camelcasing keys, etc.); This greatly facilitates the task of passing the props to the next element without performing any additional transformation.</p>
<p>And finally, to help preserve the code style, rumext offers a way for the destructuring to also take into account the rules and conventions of react for the props keys. This is achieved with the metadata <code>{::mf/props :react}</code> or by putting the suffix <code>*</code> in the component name. With that, the destructuring can use the lisp-case for keys and the macro will automatically generate the appropriate access code to the value with camelCase from the props, respecting the react convention.</p>
<pre><code>(mf/defc my-label*
  {::mf/props :obj}
  [{:keys [name class] :rest props}]
  (let [class (or class "my-label")
        props (mf/spread-props props {:class class})]
    [:&gt; :label props name]))
</code></pre>
<p>But remember: <strong>the <code>*</code> only changes the behavior of destructuring</strong>. The call convention is determined by the used handler: <code>[:&amp;</code> or <code>[:&gt;</code>.</p>
<h2><a href="#props-checking" id="props-checking"></a>Props Checking</h2>
<p>The rumext library comes with two approaches for checking props: <strong>simple</strong> and <strong>malli</strong>.</p>
<p>Lets start with the <strong>simple</strong>, which consists on simple existence check or plain predicate checking:</p>
<pre><code class="language-clojure">(mf/defc button
  {::mf/props :obj
   ::mf/expect #{:name :on-click}}
  [{:keys [name on-click]}]
  [:button {:on-click on-click} name])
</code></pre>
<p>The prop names obeys the same rules as the destructuring so you should use the same names in destructuring. Sometimes a simple existence check is not enought, for that cases you can pass a map where keys are props and values predicates:</p>
<pre><code class="language-clojure">(mf/defc button
  {::mf/props :obj
   ::mf/expect {:name string?
                :on-click fn?}}
  [{:keys [name on-click]}]
  [:button {:on-click on-click} name])
</code></pre>
<p>If that is not enough, it also supports <strong><a href="https://github.com/metosin/malli">malli</a></strong> as validation mechanism for props:</p>
<pre><code class="language-clojure">(def ^:private schema:props
  [:map {:title "button:props"}
   [:name string?]
   [:class {:optional true} string?]
   [:on-click fn?]])

(mf/defc button
  {::mf/props :obj
   ::mf/schema schema:props}
  [{:keys [name on-click]}]
  [:button {:on-click on-click} name])
</code></pre>
<p>The prop names on schema obeys the destructuring rules for key casing.</p>
<p><strong>NOTE</strong>: The props checking obey the <code>:elide-asserts</code> compiler option and they are removed on production builds.</p>
<h2><a href="#higher-order-components" id="higher-order-components"></a>Higher-Order Components</h2>
<p>This is the way you have to extend/add additional functionality to a function component. Rumext exposes one:</p>
<ul>
<li><code>mf/memo</code>: analogous to <code>React.memo</code>, adds memoization to the component based on props comparison.</li>
<li><code>mf/memo'</code>: identical to the <code>React.memo</code></li>
</ul>
<p>In order to use the high-order components, you need wrap the component manually or passing it as a special property in the metadata:</p>
<pre><code class="language-clojure">(mf/defc title
  {::mf/wrap [mf/memo]
   ::mf/props :obj}
  [props]
  [:div {:class "label"} (:name props)])
</code></pre>
<p>By default <code>identical?</code> predicate is used for compare props; you can pass a custom comparator function as second argument:</p>
<pre><code class="language-clojure">(mf/defc title
  {::mf/wrap [#(mf/memo % =)]}
  [props]
  [:div {:class "label"} (:name props)])
</code></pre>
<p>If you want create a own high-order component you can use <code>mf/fnc</code> macro:</p>
<pre><code class="language-clojure">(defn some-factory
  [component param]
  (mf/fnc myhighordercomponent
    {::mf/props :obj}
    [props]
    [:section
     [:&gt; component props]]))
</code></pre>
<p>The wrap is a generic mechanism for higher-order components, so you can create your own wrappers when you need somethig specific.</p>
<h3><a href="#special-case-for-memo" id="special-case-for-memo"></a>Special case for <code>memo</code></h3>
<p>For convenience, rumext has a special metadata <code>::mf/memo</code> that facilitates a bit the general case for component props memoization. If you pass <code>true</code>, then it will behave the same way as <code>::mf/wrap [mf/memo]</code> or <code>React.memo(Component)</code>. You also can pass a set of fields, in this case it will create a specific function for testing for equality of that specific set of props.</p>
<h2><a href="#hooks" id="hooks"></a>Hooks</h2>
<p>The rumext library exposes a few specific hooks and some wrappers over existing react hooks in addition to the hooks that react offers itself.</p>
<p>You can use both one and the other interchangeably, depending on which type of API you feel most comfortable with. The react hooks are exposed as is in react, with the function name in camelCase and the rumext hooks use the lisp-case syntax.</p>
<p>Only a subset of available hooks is documented here, please refer to the API reference documentation for deatailed information of available hooks.</p>
<h3><a href="#use-state" id="use-state"></a>use-state</h3>
<p>This is analogous hook to the <code>React.useState</code>. It exposes the same functionality but using ClojureScript atom interface.</p>
<p>Calling <code>mf/use-state</code> returns an atom-like object that will deref to the current value and you can call <code>swap!</code>  and <code>reset!</code>  on it for modify its state.</p>
<p>Any mutation will schedule the component to be rerendered.</p>
<pre><code class="language-clojure">(require '[rumext.v2 as mf])

(mf/defc local-state
  [props]
  (let [local (mf/use-state 0)]
    [:div {:on-click #(swap! local inc)}
      [:span "Clicks: " @local]]))

</code></pre>
<p>Alternatively, you can use the react hook directly:</p>
<pre><code class="language-clojure">(mf/defc local-state
  [props]
  (let [[counter update-conter] (mf/useState 0)]
    [:div {:on-click (partial update-conter #(inc %))}
      [:span "Clicks: " counter]]))
</code></pre>
<h3><a href="#use-var" id="use-var"></a>use-var</h3>
<p>In the same way as <code>use-state</code> returns an atom like object. The unique difference is that updating the ref value does not schedules the component to rerender. Under the hood it uses useRef hook.</p>
<h3><a href="#use-effect" id="use-effect"></a>use-effect</h3>
<p>Analgous to the <code>React.useEffect</code> hook with minimal call convention change (the order of arguments inverted).</p>
<p>This is a primitive that allows incorporate probably efectful code into a functional component:</p>
<pre><code class="language-clojure">(mf/defc local-timer
  [props]
  (let [local (mf/use-state 0)]
    (mf/use-effect
      (fn []
        (let [sem (js/setInterval #(swap! local inc) 1000)]
          #(js/clearInterval sem))))
    [:div "Counter: " @local]))
</code></pre>
<p>The <code>use-effect</code> is a two arity function. If you pass a single callback function it acts like there are no dependencies, so the callback will be executed once per component (analgous to <code>didMount</code> and <code>willUnmount</code>).</p>
<p>If you want to pass dependencies you have two ways:</p>
<ul>
<li>passing an js array</li>
<li>using <code>rumext.v2/deps</code> helper</li>
</ul>
<pre><code class="language-clojure">(mf/use-effect
  (mf/deps x y)
  (fn [] (do-stuff x y)))
</code></pre>
<p>And finally, if you want to execute it on each render, pass <code>nil</code> as deps (much in the same way as raw useEffect works).</p>
<p>For convenience, there is a <code>mf/with-effect</code> macro that drops one level of indentation:</p>
<pre><code class="language-clojure">(mf/defc local-timer
  [props]
  (let [local (mf/use-state 0)]
    (mf/with-effect []
      (let [sem (js/setInterval #(swap! local inc) 1000)]
        #(js/clearInterval sem)))
    [:div "Counter: " @local]))
</code></pre>
<p>Here, the deps must be passed as elements within the vector (the first argument).</p>
<p>Obviously you can use the react hook directly via <code>mf/useEffect</code>.</p>
<h3><a href="#use-memo" id="use-memo"></a>use-memo</h3>
<p>In the same line as the <code>use-effect</code>, this hook is analogous to the react <code>useMemo</code> hook with order of arguments inverted.</p>
<p>The purpose of this hook is return a memoized value.</p>
<p>Example:</p>
<pre><code class="language-clojure">(mf/defc sample-component
  [{:keys [x]}]
  (let [v (mf/use-memo (mf/deps x) #(pow x 10))]
    [:span "Value is:" v]))
</code></pre>
<p>On each render, while <code>x</code> has the same value, the <code>v</code> only will be calculated once.</p>
<p>This also can be expressed with the <code>rumext.v2/with-memo</code> macro that removes a level of indentantion:</p>
<pre><code class="language-clojure">(mf/defc sample-component
  [{:keys [x]}]
  (let [v (mf/with-memo [x]
            (pow x 10))]
    [:span "Value is:" v]))
</code></pre>
<h3><a href="#use-fn" id="use-fn"></a>use-fn</h3>
<p>Is a special case of <code>use-memo</code>. An alias for <code>use-callback</code>.</p>
<h3><a href="#deref" id="deref"></a>deref</h3>
<p>A rumext custom hook that adds ractivity to atom changes to the component:</p>
<p>Example:</p>
<pre><code class="language-clojure">(def clock (atom (.getTime (js/Date.))))
(js/setInterval #(reset! clock (.getTime (js/Date.))) 160)

(mf/defc timer
  [props]
  (let [ts (mf/deref clock)]
    [:div "Timer (deref)" ": "
     [:span ts]]))
</code></pre>
<p>Internally it uses the <code>react.useSyncExternalStore</code> API together with the ability of atom to watch it.</p>
<h2><a href="#faq" id="faq"></a>FAQ</h2>
<h3><a href="#differences-with-rum" id="differences-with-rum"></a>Differences with RUM</h3>
<p>This project is originated as a friendly fork of <a href="https://github.com/tonsky/rum">rum</a> for a personal use but it is evolved to be a completly independent library that right now does not depend on it and probably no longer preserves any of the original code. In any case, many thanks to Tonksy for creating rum.</p>
<p>This is the list of the main differences:</p>
<ul>
<li>use function based components instead of class based components.</li>
<li>a clojurescript friendly abstractions for React Hooks.</li>
<li>the component body is compiled statically (never interprets at runtime thanks to <strong>hicada</strong>).</li>
<li>performance focused, with a goal to offer almost 0 runtime overhead on top of React.</li>
</ul>
<p><strong>WARNING</strong>: it is mainly implemented to be used in <a href="https://github.com/penpot/penpot">penpot</a> and released as separated project for conveniendce. Don’t expect compromise for backward compatibility beyond what the penpot project needs.</p>
<h2><a href="#license" id="license"></a>License</h2>
<p>Licensed under MPL-2.0 (see LICENSE file on the root of the repository)</p>
</div></div></div></body></html>